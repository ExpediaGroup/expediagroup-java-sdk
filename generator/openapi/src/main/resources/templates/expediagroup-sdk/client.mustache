{{>licenseInfo}}
package com.expediagroup.sdk.{{namespace}}.client

import kotlinx.coroutines.runBlocking
import java.util.stream.Collectors
import kotlin.collections.Map.Entry

{{#imports}}
    import {{import}}
{{/imports}}

{{>imports/domain}}

{{>imports/core}}

{{>imports/helpers}}

{{>imports/defaults}}

/**
* {{#openAPI}}{{#info}}{{{description}}}{{/info}}{{/openAPI}}
*/

class {{clientClassname}}Client private constructor(clientConfiguration: {{>partials/clientConfiguration}}) : {{>partials/clientBase}}("{{namespace}}", clientConfiguration){
    {{>partials/helpers}}

    class Builder : {{>partials/clientBase}}.Builder<Builder>() {
        override fun build() = {{clientClassname}}Client(
            {{>partials/clientConfiguration}}(key, secret, endpoint, requestTimeout, connectionTimeout, socketTimeout, maskedLoggingHeaders, maskedLoggingBodyFields {{>partials/authEndpoint}})
        )
    }

    companion object {
        @JvmStatic fun builder() = Builder()
    }

    override suspend fun throwServiceException(response: HttpResponse, operationId: String) {
        throw ErrorObjectMapper.process(response, operationId)
    }

    private suspend inline fun <reified RequestType> executeHttpRequest(operation: Operation<RequestType>): HttpResponse {
        return httpClient.request {
            method = HttpMethod.parse(operation.method)
            url(operation.url)

            operation.params?.getHeaders()?.forEach { (key, value) ->
                headers.append(key, value)
            }

            operation.params?.getQueryParams()?.forEach { (key, value) ->
                url.parameters.appendAll(key, value)
            }

            appendHeaders(operation.transactionId)
            validateConstraints(operation.requestBody)
            contentType(ContentType.Application.Json)
            setBody(operation.requestBody)
        }
    }

    private inline fun <reified RequestType> executeWithEmptyResponse(operation: Operation<RequestType>) : EmptyResponse {
        try {
            return GlobalScope.future(Dispatchers.IO) {
                val response = executeHttpRequest(operation)
                throwIfError(response, operation.operationId)
                EmptyResponse(response.status.value, response.headers.entries())
            }.get()
        } catch (exception: Exception) {
            exception.handle()
        }
    }

    private inline fun <reified RequestType, reified ResponseType> execute(operation: Operation<RequestType>) : Response<ResponseType> {
        try {
            return GlobalScope.future(Dispatchers.IO) {
                val response = executeHttpRequest(operation)
                throwIfError(response, operation.operationId)
                Response(response.status.value, response.body<ResponseType>(), response.headers.entries())
            }.get()
        } catch (exception: Exception) {
            exception.handle()
        }
    }

    {{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
        /**
        * {{{summary}}}
        * {{{notes}}}
        * @param operation [{{operationIdCamelCase}}Operation]
        {{#throwsExceptions}}{{/throwsExceptions}}
        * @return a [Response] object with a body of type {{{returnType}}}{{^returnType}}Nothing{{/returnType}}
        */
        fun execute(operation: {{operationIdCamelCase}}Operation) : {{#returnType}}Response<{{{returnType}}}>{{/returnType}}{{^returnType}}EmptyResponse{{/returnType}} {
            {{#returnType}}
                return execute<{{#bodyParam}}{{dataType}}{{/bodyParam}}{{^hasBodyParam}}Nothing{{/hasBodyParam}}, {{{returnType}}}>(operation)
            {{/returnType}}
            {{^returnType}}
                return executeWithEmptyResponse<{{#bodyParam}}{{dataType}}{{/bodyParam}}{{^hasBodyParam}}Nothing{{/hasBodyParam}}>(operation)
            {{/returnType}}
        }

        {{#isPaginatable}}
            {{>client/paginatorMethods}}
        {{/isPaginatable}}
    {{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}